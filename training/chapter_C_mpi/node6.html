<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2012 (1.2)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Point to Point Communications</TITLE>
<META NAME="description" CONTENT="Point to Point Communications">
<META NAME="keywords" CONTENT="chapter_C_mpi">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2012">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="chapter_C_mpi.css">

<LINK REL="next" HREF="node10.html">
<LINK REL="previous" HREF="node2.html">
<LINK REL="up" HREF="node1.html">
<LINK REL="next" HREF="node7.html">
</HEAD>

<BODY >
<!--Navigation Panel-->
<A NAME="tex2html118"
  HREF="node7.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="file:/usr/share/latex2html/icons/next.png"></A> 
<A NAME="tex2html116"
  HREF="node1.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="file:/usr/share/latex2html/icons/up.png"></A> 
<A NAME="tex2html110"
  HREF="node5.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="file:/usr/share/latex2html/icons/prev.png"></A>   
<BR>
<B> Next:</B> <A NAME="tex2html119"
  HREF="node7.html">Transferring Data from Arrays</A>
<B> Up:</B> <A NAME="tex2html117"
  HREF="node1.html">Introduction to MPI Programming</A>
<B> Previous:</B> <A NAME="tex2html111"
  HREF="node5.html">Exercises</A>
<BR>
<BR>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION00120000000000000000">
Point to Point Communications</A>
</H1>
In this section, we will examine point to point message passing
which allows data transfer from one process to another.  Unlike
collective communications, point to point message passing involves
only a pair of processes.

<P>
Sending a scalar variable or an array from one process requires
calling one of the MPI send subroutines. This initiates data transfer from
the user buffer to the system buffer. The corresponding receive
call, on the other hand, allows data to be copied from the system
buffer to the user buffer in the destination process. There is a
variety of MPI send subroutines allowing communication in
different modes  - synchronous, buffered, ready, standard blocking
and non-blocking.  Unlike send, there are only two types of
receive subroutines: standard blocking and nonblocking. Here, we
will focus on blocking and nonblocking communications, as they are
the most commonly used modes.

<P>
When we use the blocking send subroutine, MPI_Send, control does
not return to the program until the data transfer to the system
buffer is complete. Similarly, control returns from the blocking
receive subroutine, <BR>
MPI_Recv, only after the data is copied to the
user buffer. On the other hand, nonblocking communication
subroutines, MPI_Isend and MPI_Irecv, indicate that the data
transfer has only begun. Control immediately returns to the
program while data transfer continues in the background. Note that
incorrect communications occur if we change the buffer content
before data transfer is complete. Therefore, somewhere in the
program, we have to make sure that the communication is over by
calling  MPI_Wait. The format for  MPI_Wait is as follows:

<P>
<PRE>
int MPI_Wait (
               MPI_Request  *request,
               MPI_Status   *status)
</PRE>

<P>
Now, let us take a look at the following example program where a
different scalar variable is initialized on each process.  The
processes communicate and calculate the sum of these variables.
To handle the boundry conditions we introduce the <I>MPI_PROC_NULL</I>
constant.<A NAME="57"></A> This constant is the equivalent of
using /dev/null in normal programming.  Messages sent to MPI_PROC_NULL
are treated as if the send and receive completed immediately, but not
communications occur. 

<P>
<PRE>
/* This program shows the correct and incorrect use*/
/*of the MPI_Isend and MPI_Irecv functions */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;mpi.h&gt;


main(int argc, char* argv[]){
   int my_rank,root=0;
   int nprocs;
   int inext,iprev,result=0;
   int a=0,b=0,c=0,d=0,f=0,e=0;
   MPI_Status status;
   MPI_Request sendReq1,sendReq2,recvReq1,recvReq2;
   
   /*Start MPI*/
   MPI_Init(&amp;argc, &amp;argv);
   
   /*Find out process rank*/
   MPI_Comm_rank(MPI_COMM_WORLD, &amp;my_rank);
   
   /*Find out the number of processes*/
   MPI_Comm_size(MPI_COMM_WORLD, &amp;nprocs);
  
   /*Define next and previous processes in */
   /*terms of ranks*/
   inext=my_rank+1;
   iprev=my_rank-1;
   
   /* define proc null for falling off the end */
   if (my_rank == (nprocs-1)) inext=MPI_PROC_NULL; 
   
   if  (my_rank == root) iprev=MPI_PROC_NULL;

   /* Initialize a in process 0 and b in process 1 */
   a = my_rank;
   b = my_rank+10;
   d = my_rank;
   e = my_rank+10;
   /*    Data exchange    */
   MPI_Isend(&amp;a,1,MPI_INT,
      inext,0,MPI_COMM_WORLD,&amp;sendReq1);

   MPI_Isend(&amp;b,1,MPI_INT,
      inext,0,MPI_COMM_WORLD,&amp;sendReq2);

   MPI_Irecv(&amp;a,1,MPI_INT,
      iprev,0,MPI_COMM_WORLD,&amp;recvReq1);

   MPI_Irecv(&amp;b,1,MPI_INT,
      iprev,0,MPI_COMM_WORLD,&amp;recvReq2);


   /*   Calculate c  and d before MPI_WAIT */
   c=a+b;
   f=d+e; 
   printf("Process %d before wait c= %d f= %d\n",
			 my_rank,c,f);
	    
   MPI_Wait(&amp;sendReq1,&amp;status);
   MPI_Wait(&amp;sendReq2,&amp;status);
   MPI_Wait(&amp;recvReq1,&amp;status);
   MPI_Wait(&amp;recvReq2,&amp;status);

   /*   Calculate c after MPI_Wait */
   c=a+b;
   f=d+e; 
   printf("Process %d after wait c= %d f=%d\n", 
			   my_rank,c,f);

   /* Shutdown MPI */
   MPI_Finalize();

}

*********************************************
Output from program (Sorted for easy reading)
Process 0 before wait c= 10 f= 10
Process 0 after wait c= 10 f=10
Process 1 before wait c= 12 f= 12
Process 1 after wait c= 10 f=12
Process 2 before wait c= 14 f= 14
Process 2 after wait c= 12 f=14
</PRE>

<P>
This program generates a wrong value for c when it is calculated
before the MPI_WAIT call.  MPI_Wait is used to block both
sending and receiving processes until the communication is
complete. Since the variable f can be calculated correctly during
data exchange, it is safe to post MPI_Wait calls afterwards. On
the other hand, placing MPI_Wait just after the immediate Send
and Receive calls would be the same as using blocking
communications. Please note that, to reduce synchronization
overhead, we should post MPI_Wait in the program as late as
possible. Notice one other aspect of this program.  The values are
correct for Process 0, because it receives from MPI_PROC_NULL.  
So special care must be taken in debugging these situations.

<P>
We use immediate calls because they are faster than blocking
communications. Also, blocking calls may fail when the sent
message is too large.

<P>
<BR><HR>
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html120"
  HREF="node7.html">Transferring Data from Arrays</A>
<UL>
<LI><A NAME="tex2html121"
  HREF="node8.html">Derived Data Types</A>
</UL>
<BR>
<LI><A NAME="tex2html122"
  HREF="node9.html">Exercises</A>
</UL>
<!--End of Table of Child-Links-->
<HR>
<!--Navigation Panel-->
<A NAME="tex2html118"
  HREF="node7.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="file:/usr/share/latex2html/icons/next.png"></A> 
<A NAME="tex2html116"
  HREF="node1.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="file:/usr/share/latex2html/icons/up.png"></A> 
<A NAME="tex2html110"
  HREF="node5.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="file:/usr/share/latex2html/icons/prev.png"></A>   
<BR>
<B> Next:</B> <A NAME="tex2html119"
  HREF="node7.html">Transferring Data from Arrays</A>
<B> Up:</B> <A NAME="tex2html117"
  HREF="node1.html">Introduction to MPI Programming</A>
<B> Previous:</B> <A NAME="tex2html111"
  HREF="node5.html">Exercises</A>
<!--End of Navigation Panel-->
<ADDRESS>
root
2015-12-02
</ADDRESS>
</BODY>
</HTML>
