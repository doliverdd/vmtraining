<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2012 (1.2)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Derived Data Types</TITLE>
<META NAME="description" CONTENT="Derived Data Types">
<META NAME="keywords" CONTENT="chapter_d_C">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2012">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="chapter_d_C.css">

<LINK REL="previous" HREF="node7.html">
<LINK REL="up" HREF="node7.html">
<LINK REL="next" HREF="node9.html">
</HEAD>

<BODY >
<!--Navigation Panel-->
<A NAME="tex2html139"
  HREF="node9.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="file:/usr/share/latex2html/icons/next.png"></A> 
<A NAME="tex2html137"
  HREF="node7.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="file:/usr/share/latex2html/icons/up.png"></A> 
<A NAME="tex2html133"
  HREF="node7.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="file:/usr/share/latex2html/icons/prev.png"></A>   
<BR>
<B> Next:</B> <A NAME="tex2html140"
  HREF="node9.html">Exercises</A>
<B> Up:</B> <A NAME="tex2html138"
  HREF="node7.html">Transferring Data from Arrays</A>
<B> Previous:</B> <A NAME="tex2html134"
  HREF="node7.html">Transferring Data from Arrays</A>
<BR>
<BR>
<!--End of Navigation Panel-->

<H3><A NAME="SECTION00121100000000000000">
Derived Data Types</A>
</H3>
Now, let us see how to transfer rows in an array.  A new data type
must be defined in order to send and receive rows because this
time the data is not contiguous in the memory. The following
Send/Receive pair can be used to transfer the first row of the
following array.
<PRE>
            1 2 3 4
            1 2 3 4
            1 2 3 4
            1 2 3 4
</PRE>

<P>
<PRE>
        CALL MPI_TYPE_VECTOR(4,1,4,MPI_DOUBLE_PRECISION,rowtype,ierr)
        CALL MPI_TYPE_COMMIT(ROWTYPE,IERR)

        IF (MYRANK.EQ.0) THEN
         CALL MPI_SEND(A(1,1),1,rowtype,
   &amp;     1,1,MPI_COMM_WORLD,ISEND2,IERR)
        ENDIF

        IF (MYRANK.EQ.1) THEN
         CALL MPI_RECV(A(1,1),1,rowtype,
   &amp;  0,1,MPI_COMM_WORLD,IRECV2,IERR)

        CALL MPI_TYPE_FREE(rowtype,ierr)
</PRE>

<P>
The MPI_TYPE_VECTOR subroutine is used to define a new data type
representing equally spaced blocks.  It has the following format:

<P>
<PRE>
MPI_TYPE_VECTOR(COUNT, BLOCKLENGTH, STRIDE, OLDTYPE,
NEWTYPE,IERROR):

COUNT           Number of blocks BLOCKLENGTH     Number of
elements in each block STRIDE          Number of elements between
two succesive blocks OLDTYPE         Old data type NEWTYPE
New data type IERR            Fortran return code
</PRE>

<P>
The MPI_TYPE_COMMIT makes the new data type ready to be used in
communication. The new data type is freed by the MPI_TYPE_FREE
call. In other words, the MPI_TYPE_FREE routine sets the new
data type to MPI_DATATYPE_NULL.

<P>
<BR><HR>
<ADDRESS>
root
2015-12-02
</ADDRESS>
</BODY>
</HTML>
